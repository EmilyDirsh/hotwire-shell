<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" type="text/css" href="hotwire.css" />
    <title>Hotwire - A free object-oriented hypershell</title>
  </head>
  <body>
    <div id="main">
    <div id="top">
      <img src="title01.png" border="0" height="229" width="432" alt="Hotwire: An object-oriented hypershell" />
      <img src="title02.png" border="0" height="229" alt="Small screenshot of Hotwire" style="text-align: right;" />
    </div>
    <div id="left">
      <div class="box">
        <h2 class="box_title">Downloads</h2>
        <h4 class="box_header">Source</h4>
        The current version of Hotwire is <b>0.700</b> (Jan 23, 2008):
        <a href="http://code.google.com/p/hotwire-shell/wiki/HotwireChanges#Changes_in_Hotwire_0.700_(Current_Release)">ChangeLog</a>, 
        <a href="http://hotwire-shell.googlecode.com/files/hotwire-0.700.zip">Source</a>.
        <ul>
          <li><a href="http://code.google.com/p/hotwire-shell/downloads/list">All Releases</a></li>
          <li><a href="http://hotwire-shell.googlecode.com/svn/trunk/">SVN Repository</a></li>
        </ul>        
        <h4 class="box_header">Linux/Unix</h4>
        See this wiki page for distribution status:
        <a href="http://code.google.com/p/hotwire-shell/wiki/HotwireUnixLinux">Linux/Unix packages</a>
        <h4 class="box_header">Other systems</h4>
        Hotwire for Windows and MacOS X is in progress but not
        ready for general use.  See these wiki pages for the
        status of the ports:
        <ul>
        <li><a href="http://code.google.com/p/hotwire-shell/wiki/HotwireWindows">Windows</a></li>
        <li><a href="http://code.google.com/p/hotwire-shell/wiki/HotwireMacOSX">MacOS X</a></li>
        </ul>
      </div>
      <div class="box">
        <h2 class="box_title">Screenshots</h2>
        <p>See Colin's <a href="http://picasaweb.google.com/cgwalters/HotwireScreenshots">Hotwire gallery</a>.</p>
        <center>
        <a href="http://picasaweb.google.com/cgwalters/HotwireScreenshots"><img src="http://lh4.google.com/cgwalters/R5V1dyVMmnE/AAAAAAAABBw/WTdZU6TonKI/s160-c/HotwireScreenshots.jpg" width="160" height="160" style="border:1px solid grey;"/></a>
        </center>
      </div>      
      <div class="box">
        <h2 class="box_title">Community</h2>
        <p>Join the <a href="http://groups.google.com/group/hotwire-shell">Discussion Group</a></p>
        <p>Browse the <a href="http://code.google.com/p/hotwire-shell/">developer wiki</a></p>
      </div>
      <div class="box">
        <h2 class="box_title">Media</h2>
        Oct 2007 - <a href="http://arstechnica.com/journals/linux.ars/2007/10/29/ars-at-fosscamp-revolutionizing-the-command-line-with-hotwire">Ars Technica article</a> on Hotwire.
        <br/>
        Nov 2007 - <a href="http://www.linux.com/feature/121743">Linux.com article</a> on Hotwire.
      </div>
    </div>
    <div id="right">
      <h3>What is Hotwire?</h3>
      <p>Hotwire is an object-oriented hypershell.  It is a shell designed for systems programming (files, processes), 
         and thus it is in the same conceptual category of software as the Unix shell+terminal and Windows PowerShell.</p>
       
      <p><i>(To learn more interactively than reading background here, you could try downloading a version of Hotwire for your
          operating system and experiment with it; see the links on the left.)</i></p>
         
      <p>The goal of the Hotwire project though is to create a better systems programming shell than <b>both</b> Unix and PowerShell.  We call
         it a <i>hyper</i>-shell because Hotwire blends the concepts of a systems-oriented shell with a modern graphical user interface
         display.  It takes advantage of your desktop environment rather than being a text box.  It retains some advantageous attributes of a shell
         such as keyboard command orientation, interactivity, completion, and scripting.</p>
      <p>From an implementation perspective, at the heart of Hotwire is the concept of asynchronous object-oriented pipeline processing.  Layered on 
         top of this in a tightly integrated fashion is a graphical display, control and introspection system.</p>
         
      <center>
        <a href="http://picasaweb.google.com/cgwalters/HotwireScreenshots/photo#5158520308695541106"><img src="http://lh5.google.com/cgwalters/R5a-48ZvpXI/AAAAAAAABDc/1tx4ZQD3Ajs/s288/Hotwire-help.png" /></a>
        <br/>
        <i>Hyperlinked help display</i>
      </center>
          
      <h3>How is Hotwire better than Unix?</h3>
      
        <p>Hotwire merges the concepts of Unix terminal emulator and shell into one integrated process, using
           a modern programming language runtime.  It supersets Unix out-of-process bytestream pipelines in favor of an 
           in-process object-oriented pipeline, while still allowing invocation of out-of-process Unix binaries which 
           output text.  Because the shell and display now understand the type of output rather than just 
           displaying a text stream, the system can be far more intelligent.</p>
           
        <center>
          <a href="http://picasaweb.google.com/cgwalters/HotwireScreenshots/photo#5158158227364158082"><img src="http://lh6.google.com/cgwalters/R5V1lCVMmoI/AAAAAAAABA8/0O7VXZMsDSY/s288/Hotwire-oinspector-filter.png" /></a>
          <br/>
          <i>Hotwire showing a system process list</i>
        </center>           
           
        <p>Considered from a modern perspective, the Unix terminal is two things.  First, it is a container for the display of human-readable Unicode text, suitable for 
        applications like the Unix shell (e.g. <tt>bash</tt>) which can run other programs that output text.  Think <tt>ls</tt> (without colors) 
        <tt>dmesg</tt>, <tt>ps</tt>, <tt>cat</tt> (on plain text files), etc.  A much smaller percentage take lines of input for a question or two.</p>

        <p>Secondarily, the Unix terminal is also a poor GUI toolkit.  One might challenge this - how is the terminal also 
           a GUI?  Here we are defining a GUI program as one whose output is not suitable to be piped into another arbitrary program.  
           Today there are few commonly used applications written for the terminal GUI.  Examples are <tt>vi</tt>, 
           <tt>mutt</tt>, <tt>man</tt>, and various others.  These programs <i>are not suitable for scripting</i>, and thus are 
           equivalent to conventional GUI applications from the perspective of a shell.</p>

        <p>With this in mind, you can now understand that Hotwire does not attempt to implement an extended terminal GUI (though
           there is a <b>term</b> builtin to launch terminals easily).  Now, we can assume that all system commands output plain text, 
           and so the environment can be optimized for text processing.
           For example, Hotwire keeps the entire output of every command by default, and allows for Firefox-style search.</p>
           
         <p>Hotwire allows you to <i>interactively</i> refine pipelines by piping the output of the previous command into a new one,
           without re-executing the last command.  For example, if you've ever created a diff using a slow revision control system and then
           wanted to save it to a file or search/grep it, this feature is extremely valuable. 
        </p>
        
        <center>
          <a href="http://picasaweb.google.com/cgwalters/HotwireScreenshots/photo#5158178491019860690"><img src="http://lh4.google.com/cgwalters/R5WIAiVMmtI/AAAAAAAABBs/_3AodTVQxfM/s288/Hotwire-lspci-search.png" /></a>
          <br/>
          <i>Interactive search over lspci output</i>
        </center>
        
      <h3>How is Hotwire better than Windows PowerShell?</h3>
      
        <p>Hotwire shares a conceptual heritage with PowerShell's object-oriented underpinnings.  However, Hotwire makes a number of different design decisions,
           and the result is a very different program.  For a start, Hotwire was designed for a rich, interactive graphical interface.  While third party 
           PowerShell environments exist, the result isn't the same as if the entire system was designed for it from the start.
        </p>
        
        <center>
          <a href="http://picasaweb.google.com/cgwalters/HotwireScreenshots/photo#5158515279288837442"><img src="http://lh6.google.com/cgwalters/R5a6UMZvpUI/AAAAAAAABCw/3CWZZoqfgOY/s288/Hotwire-history-search.png" /></a>
          <br/>
          <i>History search</i>
        </center>
        
        <p>Another design choice is that the Hotwire project made the decision very early not to attempt to create a full new scripting language.  Hotwire
           does have a small Unix-inspired pipeline syntax, but a major goal of the project is to make it as easy for 
           users to leverage well-known existing programming languages such as Python and Ruby - and (where available) Unix shell script.</p>
           
        <center>
          <a href="http://picasaweb.google.com/cgwalters/HotwireScreenshots/photo#5158521519876318594"><img src="http://lh3.google.com/cgwalters/R5a__cZvpYI/AAAAAAAABDo/Q8845XmZOf0/s288/Hotwire-shellscript.png" /></a>
          <br/>
          <i>Running a Unix shell script in Hotwire</i>
        </center>
           
        <p>Finally, Hotwire has a much more day-to-day system interaction feel to it than PowerShell does.  For example, Hotwire is fanatical
           about saving your history, and making it easy to find frequently used commands and directories again.  Hotwire integrates with the desktop - its builtin <b>rm</b>
           moves files to the Trash.  And going further, on Unix Hotwire integrates closely with other systems programming tools like OpenSSH;
           the <b>ssh</b> builtin allows completion from <tt>known_hosts</tt>, and it is a longer-term goal for Hotwire to provide the best
           possible SSH experience.</p>
        
      <h3>Does Hotwire mean rewriting Unix binaries in Python to output and process objects?</h3>
      
      <p>This question gets to the heart of what the project is.  The answer is "Some, yes".  But not all.
      The general idea is that where the builtin can provide a both useful and usable replacement, then
      we do so.  For example, Hotwire takes the <b>ls</b> name for <b>LsBuiltin</b>.  However, we chose
      to name the builtin to enumerate Processes <b>proc</b>, not <tt>ps</tt>.  That's because Unix <tt>ps</tt>
      has a number of useful formatting options and extra information that isn't included in <b>proc</b>.
      </p> 
      
      <p>The goal in a larger sense is that the Hotwire "builtins" are just <i>trivial wrappers</i> around
         real APIs.  For example, Hotwire includes a <b>http-get</b> builtin that just returns a 
         <tt>HTTPResponse</tt> object from the Python standard library:</p>
      
      <center>
        <a href="http://picasaweb.google.com/cgwalters/HotwireScreenshots/photo#5158158231659125442"><img src="http://lh3.google.com/cgwalters/R5V1lSVMmsI/AAAAAAAABBc/oKGJX0z1GDE/s288/Hotwire-httpget.png" /></a>
        <br/>
        <i>Invoking http-get</i>
      </center>
      
      <p>It is important to note here that at the current time, Hotwire's namespace is not declared stable.  Names
         may change as the system evolves.</p>
         
      <h3>What about remoting?</h3>
      
      <p>Unix terminal emulators can display not only shells running on the local system, but also on remote systems
         over protocols such as SSH.  How does Hotwire's graphical, object-oriented approach fit into this world?
         There are multiple valid approaches.  First, one can simply run a thin desktop environment on the
         remote machine, and Hotwire inside of that, connecting using a protocol such as RDP.</p>
         
      <p>The second plan is to integrate tightly with systems management frameworks such as <a href="https://hosted.fedoraproject.org/func/">Func</a>
         and <a href="http://www.reductivelabs.com/projects/puppet/">Puppet</a>.  
         In other words, Hotwire will become a "rich client" control system, allowing you to easily
         create scripts locally and then run them on various machines.</p>
         
      <p>Finally, Hotwire includes a SSH terminal application (<tt>hotwire-ssh</tt>) for the times when you want a plain
         remote pseudoterminal and shell.</p>
         
     <center>
       <a href="http://picasaweb.google.com/cgwalters/HotwireScreenshots/photo#5158518122557187426"><img src="http://lh4.google.com/cgwalters/R5a85sZvpWI/AAAAAAAABDQ/BiCDWo4EasU/s288/Hotwire-ssh.png" /></a>
       <br/>
       <i>Hotwire SSH terminal client</i>
     </center>
         
     <h3>More information</h3>
     
     <p>For further details, you should take a look at the <a href="http://code.google.com/p/hotwire-shell">developer wiki</a>.</p>
 
    </div>
    <div id="copyright"></div>
    </div>
    
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-1762047-1");
pageTracker._initData();
pageTracker._trackPageview();
</script>

  </body>
</html>
