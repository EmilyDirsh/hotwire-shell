#summary Description of Hotwire architecture
= Hotwire architecture =

== Introduction to pipelines ==

The fundamental unit of Hotwire is the concept of an object-oriented pipeline.  A pipeline is composed of a chain of Hotwire *Builtins*, which are Python classes with a specific API.

A Hotwire *Builtin* in general takes as input a stream of objects, a set of arguments and options, and yields another object stream.  All of this is optional though; for example some builtins such as `rm` (*RmBuiltin*), only operate on their argument list, and don't input or output anything.  Others don't take any arguments.

Let's start with a simple example, in the HotwirePipe language:

{{{
proc | filter -i walters owner_name
}}}

This example finds all processes on the system whose `owner_name` property matches the regular expression "walters".   Note that unlike a traditional text-line based Unix `/bin/sh` pipeline, this will not be misled by other extraneous text
which happens to match the input (no `grep -v grep`).

`proc` references the *ProcBuiltin* class, which is outputting a stream of *Process* objects.  `filter` references the *FilterBuiltin* class, which can take any input type, and will output the same type.  The `walters` and `owner_name` are string arguments for *FilterBuiltin*, and `-i` is processed as an option.

Don't be fooled by the similarity to Unix shell syntax - in this example everything is in the Hotwire process; there is no execution of external programs.

When you give this command to Hotwire, it looks up the names `proc` and `filter` in the registry, parses the options and argument list, and then executes it.  Each component of a pipeline is executed in a new thread.  These threads then simply call the *execute* method of each *Builtin* object, which takes a context, arguments, and options. 

Because each builtin runs in its own thread, Hotwire internally uses threadsafe Queues to pipe objects from one thread to another.

But to make things more concrete, ignoring threading, the above pipeline is equivalent to this Python code:

{{{
import re
from hotwire.sysdep.proc import ProcessManager

prop_re = re.compile('walters')

for process in ProcessManager.getInstance().get_processes():
  if prop_re.search(process.owner_name):
    yield process
}}}

This may also be a bit clearer from looking at the [http://hotwire-shell.googlecode.com/svn/trunk/hotwire/builtins/proc.py proc source] and the [http://hotwire-shell.googlecode.com/svn/trunk/hotwire/builtins/filter.py filter source].

Unfortunately, for Hotwire we had to implement the code to list processes on a system, and create the *Process* object.  But if the Python distribution included this bit, the pipeline and builtins would just be a simpler syntax for accessing Python libraries.

This point is very important - the intent is that Hotwire builtins are mostly just _trivial wrappers_ around actual APIs which are intended to be used from Python.  They take arguments and options in a shell-like way tends to be more convenient.

=== The `sys` builtin ===

So the current list of Hotwire builtins is all well and good; we can see files using *LsBuiltin*, processes using *ProcBuiltin*, do HTTP GETs using *HttpGetBuiltin*.  But sadly, not every aspect of the operating system has a nice Python API.  For example, there is no default Python API to query active network interfaces.  Or to list hardware devices.  Or to manipulate the X server resolution.  And the list goes on.

You may recognize these commands on most Unix/Linux systems as `ifconfig`, `lshal`, and `xrandr`.  Realistically, Hotwire can't immediately ship a version of every single one of these commands.  We'd like to be able to continue using them.

== Renderers ==

Besides just generating lists of objects, Hotwire knows how to display them.
If you try the *ls* command in Hotwire, you will likely notice that Hotwire displays the appropriate icons for the file, and
turns the file name into a clickable link to open.  This is because the *ls* command generates a list of *!FilePath* objects.
The *ObjectRendererMapping* registry tells Hotwire to render *!FilePath* objects using *!FilePathRenderer*.
Renderers are unlimited in power (they're just GTK+ widgets); e.g. you could define a renderer for the *Process* class which dynamically shows its CPU usage,
add an ''Edit'' link to the !FilePathRenderer, and a lot more. 

== Remoting ==

''Note the code for the text referenced below is currently disabled until the experience works more smoothly''

Hotwire natively understands remote execution.  Currently, this means ''ssh'', and in the future ''su''.  However, the built in
'''ssh''' command does not simply execute `/usr/bin/ssh` and present a terminal.  Instead, Hotwire copies itself over to the
remote system and executes a Python interpreter, and then begins using a custom protocol to communicate.  This means
that Hotwire can be significantly more intelligent (for example, moving the cursor no longer takes a network round trip).
When logged into a remote system, pipelines are sent to that system for execution, and the results delivered back over the
network.  Additionally, Hotwire can offer extended commands:

{{{
ls *.py | download
}}}

The '''download''' command tells the remote Hotwire to notify the local Hotwire to download the list of files.  Previously,
this would have required creating a separate terminal and executing `/usr/bin/sftp`, changing to the same remote directory,
etc.  