#summary Description of Hotwire architecture
= Hotwire architecture =

Hotwire has 3 primary architectural components:

 * Pipelines
 * Renderers
 * Remoting

== Pipelines ==

A pipeline in Hotwire is composed of a sequence of commands.  A command receives as input a stream of Python objects (along with
arguments, if any), and outputs another stream of objects.  Note the contast to a `/bin/sh` pipeline which is based on byte streams,
whereas Hotwire only pipes Python objects (HotwireVsBinSh).

Here's a simple example:

{{{
proc | filter walters owner_name
}}}

(Don't be fooled by the similarity to shell syntax, there is no `/bin/sh` or in fact any external processes involved here)

This pipeline is composed of two components, the *proc* builtin and the *filter* builtin.  The ''walters'' and ''owner_name''
are arguments for *filter*.  The *proc* builtin command generates a list of all processes on the system (instances of *Process*).  If we had omitted
the second part, we would have seen this list displayed.  The *filter* command takes a regular expression and (optionally) a property
name.  Here, it is filtering the process list to objects whose ''owner_name'' attribute matches the regular expression
''walters''.  Note that unlike a traditional text-line based `/bin/sh` pipeline, this will not be misled by other extraneous text
which happens to match the input (no `grep -v grep`).

A way to think about this is that it's essentially equivalent to this Python code:
{{{
import sys,re
prop_re = re.compile('walters')
for process in sys.get_processes():
  if prop_re.search(process.owner_name):
    yield process
}}}

Internally there are other details: Hotwire actually creates a thread for each pipeline component, has some static type checking, etc.
Of course the biggest thing glossed over in the above is that Python actually has no builtin way to list system processes; that's part of Hotwire's *Platform* object.

This may also be a bit clearer from looking at the [http://hotwire-shell.googlecode.com/svn/trunk/hotwire/builtins/proc.py proc source] and the [http://hotwire-shell.googlecode.com/svn/trunk/hotwire/builtins/filter.py filter source].

== Renderers ==

Besides just generating lists of objects, Hotwire knows how to display them.
If you try the *ls* command in Hotwire, you will likely notice that Hotwire displays the appropriate icons for the file, and
turns the file name into a clickable link to open.  This is because the *ls* command generates a list of *!FilePath* objects.
The *ObjectRendererMapping* registry tells Hotwire to render *!FilePath* objects using *!FilePathRenderer*.
Renderers are unlimited in power (they're just GTK+ widgets); e.g. you could define a renderer for the *Process* class which dynamically shows its CPU usage,
add an ''Edit'' link to the !FilePathRenderer, and a lot more. 

== Remoting ==

''Note the code for the text referenced below is currently disabled until the experience works more smoothly''

Hotwire natively understands remote execution.  Currently, this means ''ssh'', and in the future ''su''.  However, the built in
'''ssh''' command does not simply execute `/usr/bin/ssh` and present a terminal.  Instead, Hotwire copies itself over to the
remote system and executes a Python interpreter, and then begins using a custom protocol to communicate.  This means
that Hotwire can be significantly more intelligent (for example, moving the cursor no longer takes a network round trip).
When logged into a remote system, pipelines are sent to that system for execution, and the results delivered back over the
network.  Additionally, Hotwire can offer extended commands:

{{{
ls *.py | download
}}}

The '''download''' command tells the remote Hotwire to notify the local Hotwire to download the list of files.  Previously,
this would have required creating a separate terminal and executing `/usr/bin/sftp`, changing to the same remote directory,
etc.  